"use strict";var w=Object.defineProperty;var S=Object.getOwnPropertySymbols;var M=Object.prototype.hasOwnProperty,V=Object.prototype.propertyIsEnumerable;var k=(s,t,e)=>t in s?w(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,v=(s,t)=>{for(var e in t||(t={}))M.call(t,e)&&k(s,e,t[e]);if(S)for(var e of S(t))V.call(t,e)&&k(s,e,t[e]);return s};var g=(s,t,e)=>{if(!t.has(s))throw TypeError("Cannot "+e)};var o=(s,t,e)=>(g(s,t,"read from private field"),e?e.call(s):t.get(s)),p=(s,t,e)=>{if(t.has(s))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(s):t.set(s,e)},f=(s,t,e,i)=>(g(s,t,"write to private field"),i?i.call(s,e):t.set(s,e),e);var b=(s,t,e)=>(g(s,t,"access private method"),e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m=require("../Store-Cr3VaD9G.cjs");var d,u,a,h,y;class q extends m.Store{constructor(e){super(e,{equalityCheck:()=>!1});p(this,h);p(this,d,void 0);p(this,u,void 0);p(this,a,void 0);f(this,d,v({},e)),f(this,u,new Map),f(this,a,new Set)}get base(){return o(this,d)}get steps(){return o(this,u)}close(){super.close(),o(this,a).clear(),o(this,u).clear()}bind(e){o(this,a).add(e)}unbind(e){o(this,a).delete(e)}deleteStep(e){this.steps.delete(e)}getStepValue(e){var i;return(i=this.steps.get(e))==null?void 0:i[1]}getExcludedStepsValue(...e){const i=new Map;return e.map(c=>{const n=this.steps.get(c);n&&i.set(c,n)}),b(this,h,y).call(this,i)}getIncludedStepsValue(...e){const i=new Map(this.steps);return e.map(c=>{this.steps.has(c)&&i.delete(c)}),b(this,h,y).call(this,i)}setStep(e,i,c){const n={};for(const r in this.current)n[r]=c[r]||0;this.steps.set(e,[i,n]),this.calculate()}calculate(){this.current=b(this,h,y).call(this,o(this,u))}}d=new WeakMap,u=new WeakMap,a=new WeakMap,h=new WeakSet,y=function(e){const i={};for(const c in this.base)i[c]=this.base[c];for(const c of e){const n=c[1];if(n[0]==="+")for(const r in this.base){const l=n[1][r];i[r]+=l}else if(n[0]==="*")for(const r in this.base){const l=n[1][r];i[r]*=l}else if(n[0]==="/")for(const r in this.base){const l=n[1][r];i[r]/=l}else if(n[0]==="-")for(const r in this.base){const l=n[1][r];i[r]-=l}}for(const c of o(this,a))for(const n in i)c[n]=i[n];return i};exports.Ladder=q;
